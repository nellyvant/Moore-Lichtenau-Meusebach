df_lt    = MTS_lt,
df_th    = MTS_th,
standort = "MT",
logger   = "S"
)
#Meusebach nass Mitte
MNM <- join_loggers(
df_lt    = MNM_lt,
df_th    = MNM_th,
standort = "MN",
logger   = "M"
)
#Meusebach nass Ost
MNO <- join_loggers(
df_lt    = MNO_lt,
df_th    = MNO_th,
standort = "MN",
logger   = "O"
)
#Meusebach nass West
MNW <- join_loggers(
df_lt    = MNW_lt,
df_th    = MNW_th,
standort = "MN",
logger   = "W"
)
#Meusebach nass Nord
MNN <- join_loggers(
df_lt    = MNN_lt,
df_th    = MNN_th,
standort = "MN",
logger   = "N"
)
#Meusebach nass Süd
MNS <- join_loggers(
df_lt    = MNS_lt,
df_th    = MNS_th,
standort = "MN",
logger   = "S"
)
# alle Daten vor dem 08.05.2025 00:00 Uhr entfernen
# alle Daten nach dem 30.9.2025 23:50 Uhr entfernen
cutoff_start <- as.POSIXct("2025-05-08 00:00:00", tz="UTC")
cutoff_end   <- as.POSIXct("2025-09-30 23:50:00", tz="UTC")
logger_names <- c("LM", "LO", "LW", "LN", "LS", "MTM", "MTO", "MTW", "MTN", "MTS", "MNM", "MNO", "MNW", "MNN", "MNS")
for (logger in logger_names) {
assign(logger, get(logger) %>%
filter(DateTime >= cutoff_start & DateTime <= cutoff_end))
}
#entfernen von Zeilen ohne Messwerte (entstanden durch Auslesen der Logger)
messwert_spalten <- c("Temp_sonne_C", "Licht_lux", "Temp_schatten_C", "relLF_percent", "Taupunkt_C")
for (logger in logger_names) {
# Tabelle holen, filtern, wieder zurückschreiben
assign(logger, get(logger) %>%
filter(!if_all(all_of(messwert_spalten), is.na)))
}
#Zusammenführen als Masterdatensatz
all_loggers <- bind_rows(lapply(logger_names, get))
str(all_loggers)
# Zeitspalte korrekt formatieren
all_loggers1 <- all_loggers %>%
mutate(DateTime = as.POSIXct(DateTime, format="%Y-%m-%d %H:%M:%S")) %>%
filter(DateTime >= as.POSIXct("2025-05-08 00:00:00") &
DateTime <= as.POSIXct("2025-09-30 23:59:59"))
# Alle Logger und Standorte explizit bestimmen
logger_list <- all_loggers1 %>%
distinct(Standort, Logger, Logger_ID)
# Zeitreihe erstellen: alle 10 Minuten vom 08.05 bis 30.09.2025
zeitpunkte <- seq(
from = as.POSIXct("2025-05-08 00:00:00", tz = "UTC"),
to   = as.POSIXct("2025-09-30 23:50:00", tz = "UTC"),
by   = "10 min"
)
# Kreuzprodukt
voller_raster <- tidyr::crossing(logger_list, zeitpunkte)
voller_raster <- voller_raster %>%
rename(DateTime = zeitpunkte)
# Originaldaten einfügen
all_loggers_complete <- voller_raster %>% left_join(all_loggers1, by = c("Standort", "Logger", "Logger_ID", "DateTime"))
# Fehlende Werte pro Zeile zählen (mindestens eine Messgröße fehlt)
fehlende_zeitpunkte <- all_loggers_complete %>%
mutate(Anzahl_NA = rowSums(is.na(select(., Temp_sonne_C, Licht_lux, Temp_schatten_C,
relLF_percent, Taupunkt_C)))) %>%
filter(Anzahl_NA > 0)  # Zeilen, bei denen mindestens eine Messgröße fehlt
# Zusammenfassung pro Logger und Standort
fehlende_werte_summary <- fehlende_zeitpunkte %>%
group_by(Standort, Logger, Logger_ID) %>%
summarise(
Temp_sonne_C_missing    = sum(is.na(Temp_sonne_C)),
Licht_lux_missing       = sum(is.na(Licht_lux)),
Temp_schatten_C_missing = sum(is.na(Temp_schatten_C)),
relLF_percent_missing   = sum(is.na(relLF_percent)),
Taupunkt_C_missing      = sum(is.na(Taupunkt_C)),
Gesamt_fehlend          = n(),   # alle Zeilen mit mindestens einem fehlenden Wert
.groups = "drop"
) %>%
arrange(Standort, Logger, Logger_ID)
df <- all_loggers %>%
filter(
Logger_ID == "MTM",
Standort == "MT"
) %>%
select(
Temp_sonne_C,
Temp_schatten_C,
relLF_percent,
Taupunkt_C,
Licht_lux
) %>%
na.omit()
cor_mat <- cor(df)
round(cor_mat, 2)
# Standort MT filtern
df_mt <- all_loggers %>%
filter(Standort == "MT")
# Wide-Format erzeugen
df_wide <- df_mt %>%
pivot_wider(
id_cols = DateTime,
names_from = Logger_ID,
values_from = c(
Temp_sonne_C,
Temp_schatten_C,
relLF_percent,
Taupunkt_C,
Licht_lux
)
)
# Ziel-Logger festlegen
target <- "MTM"
# Alle anderen Logger automatisch bestimmen
logger_ids <- unique(df_mt$Logger_ID)
logger_ids <- logger_ids[logger_ids != target]
# Korrelation berechnen
cor_results <- lapply(logger_ids, function(id){
data.frame(
Logger = id,
cor_temp_out = cor(
df_wide[[paste0("Temp_sonne_C_", target)]],
df_wide[[paste0("Temp_sonne_C_", id)]],
use = "complete.obs"
),
cor_temp_in = cor(
df_wide[[paste0("Temp_schatten_C_", target)]],
df_wide[[paste0("Temp_schatten_C_", id)]],
use = "complete.obs"
),
cor_rh = cor(
df_wide[[paste0("relLF_percent_", target)]],
df_wide[[paste0("relLF_percent_", id)]],
use = "complete.obs"
),
cor_tau = cor(
df_wide[[paste0("Taupunkt_C_", target)]],
df_wide[[paste0("Taupunkt_C_", id)]],
use = "complete.obs"
),
cor_lux = cor(
df_wide[[paste0("Licht_lux_", target)]],
df_wide[[paste0("Licht_lux_", id)]],
use = "complete.obs"
)
)
}) %>%
bind_rows()
cor_results
vars <- c(
"Temp_sonne_C",
"Temp_schatten_C",
"relLF_percent",
"Taupunkt_C",
"Licht_lux"
)
target <- "MTM"
other_loggers <- unique(df_mt$Logger_ID)
other_loggers <- other_loggers[other_loggers != target]
result <- list()
for(logger in other_loggers){
comb <- expand.grid(
MTM_var = vars,
Other_var = vars
)
comb$Other_Logger <- logger
comb$correlation <- mapply(function(v1, v2){
cor(
df_wide[[paste0(v1,"_",target)]],
df_wide[[paste0(v2,"_",logger)]],
use = "complete.obs"
)
}, comb$MTM_var, comb$Other_var)
result[[logger]] <- comb
}
cross_logger_cor <- bind_rows(result)
cross_logger_cor
###### Meusebach trocken - Mitte Logger: fehlende Daten für "Temp_sonne_C"
# 1. Variable, die analysiert werden soll
var <- "Temp_sonne_C"
# 2. Datensatz für einen bestimmten Standort vorbereiten
wide <- all_loggers %>%
select(DateTime, Standort, Logger_ID, all_of(var)) %>%
# Nur Zeilen für den Standort "MT" behalten
filter(Standort == "MT") %>%
# Lange Tabelle in breite Tabelle umwandeln: eine Spalte pro Logger_ID
pivot_wider(names_from = Logger_ID,
values_from = all_of(var)) %>%
# Nach Datum/Uhrzeit sortieren
arrange(DateTime)
# 3. Aus dem 'wide'-Datensatz werden alle Zeilen ausgewählt, bei denen 'MTM' nicht NA ist.
train <- wide %>%
filter(!is.na(MTM))
# 4. Lineares Regressionsmodell erstellen
# 'MTM' wird als abhängige Variable genommen,
# und 'MTN', 'MTS' und 'MTO' als unabhängige Variablen.
mod <- lm(MTM ~ MTN + MTS + MTO, data = train)
# 5. Zusammenfassung des Modells anzeigen
# relativ gute R² Werte, ca. 0.95
summary(mod)
# 6. Vorhersagen für alle Zeilen im Datensatz erstellen
pred <- predict(mod, newdata = wide)
# 7. Fehlende Werte in 'MTM' auffüllen
# Wenn 'MTM' NA ist, wird der vorhergesagte Wert genommen, sonst bleibt der Originalwert
wide$MTM_filled <- ifelse(
is.na(wide$MTM),
pred,
wide$MTM
)
# 8. Validierung simulieren, zufällig 2000 bekannte MTM-Werte auswählen, um sie als "fehlend" zu markieren -> Vorhersagen -> messen, wie stark die Vorhersagen von den echten Werten abweichen
set.seed(42)
idx <- sample(which(!is.na(wide$MTM)), 2000)
wide_test <- wide
wide_test$MTM[idx] <- NA
pred_test <- predict(mod, newdata = wide_test)
rmse <- sqrt(mean(
(pred_test[idx] - wide$MTM[idx])^2
))
rmse # desto kleiner, umso besser -> 2,374
# Standardabweichung von MTM berechnen -> 10,62
sd_MTM <- sd(wide$MTM, na.rm = TRUE)
sd_MTM
# Packages
library(randomForest)
# Variable definieren
var <- "Temp_sonne_C"
# Datensatz vorbereiten wie vorher
wide <- all_loggers %>%
select(DateTime, Standort, Logger_ID, all_of(var)) %>%
filter(Standort == "MT") %>%
pivot_wider(names_from = Logger_ID,
values_from = all_of(var)) %>%
arrange(DateTime)
# Zeitliche Features hinzufügen
wide$Hour <- as.numeric(format(wide$DateTime, "%H"))
wide$Weekday <- as.factor(weekdays(wide$DateTime))
wide$DayOfYear <- as.numeric(format(wide$DateTime, "%j"))
wide$Hour_sin <- sin(2 * pi * wide$Hour / 24)
wide$Hour_cos <- cos(2 * pi * wide$Hour / 24)
train <- wide %>%
filter(!is.na(MTM))
# Random Forest Modell erstellen
mod_rf <- randomForest(
MTM ~ MTN + MTS + MTO + Hour_sin + Hour_cos + Weekday + DayOfYear,
data = train,
ntree = 500,        # je mehr, desto stabiler ist das Model
mtry = 3,
importance = TRUE
)
# Modellübersicht -> man kann ableiten, wie wichtig die einzelnen Features waren (also: MTN, MTS, Hour_sin,Weekday, DayOfYear ...)
mod_rf
importance(mod_rf)
# %IncMSE zeigt an, wie stark der Fehler steigt, wenn ein Feature zufällig permutiert wird -> Je höher der Wert, desto wichtiger ist das Feature für die Gesamtvorhersage
# NodePurity sagt strukturbezogen, wie wichtig ein Feature für die Baumaufteilung ist
pred_rf <- predict(mod_rf, newdata = wide)
wide$MTM_filled_rf <- ifelse(
is.na(wide$MTM),
pred_rf,
wide$MTM
)
# RMSE validieren (wie vorher)
set.seed(42)
idx <- sample(which(!is.na(wide$MTM)), 2000)
wide_test <- wide
wide_test$MTM[idx] <- NA
pred_test_rf <- predict(mod_rf, newdata = wide_test)
rmse_rf <- sqrt(mean(
(pred_test_rf[idx] - wide$MTM[idx])^2
))
rmse_rf # deutlich besser !!!! random Modell besser als lineares
vars <- c(
"Temp_sonne_C",
"Temp_schatten_C",
"relLF_percent",
"Taupunkt_C",
"Licht_lux"
)
target <- "MTW"
other_loggers <- unique(df_mt$Logger_ID)
other_loggers <- other_loggers[other_loggers != target]
result <- list()
for(logger in other_loggers){
comb <- expand.grid(
MTW_var = vars,
Other_var = vars
)
comb$Other_Logger <- logger
comb$correlation <- mapply(function(v1, v2){
cor(
df_wide[[paste0(v1,"_",target)]],
df_wide[[paste0(v2,"_",logger)]],
use = "complete.obs"
)
}, comb$MTW_var, comb$Other_var)
result[[logger]] <- comb
}
cross_logger_cor <- bind_rows(result)
cross_logger_cor
write_xlsx(cross_logger_cor, "Korrelationstabelle_MTW.xlsx")
vars <- c(
"Temp_sonne_C",
"Temp_schatten_C",
"relLF_percent",
"Taupunkt_C",
"Licht_lux"
)
target <- "MNM"
other_loggers <- unique(all_loggers$Logger_ID)
other_loggers <- other_loggers[other_loggers != target]
result <- list()
vars <- c(
"Temp_sonne_C",
"Temp_schatten_C",
"relLF_percent",
"Taupunkt_C",
"Licht_lux"
)
target <- "MNW"
other_loggers <- unique(all_loggers$Logger_ID)
other_loggers <- other_loggers[other_loggers != target]
result <- list()
for(logger in other_loggers){
comb <- expand.grid(
MNW_var = vars,
Other_var = vars
)
comb$Other_Logger <- logger
comb$correlation <- mapply(function(v1, v2){
cor(
df_wide[[paste0(v1,"_",target)]],
df_wide[[paste0(v2,"_",logger)]],
use = "complete.obs"
)
}, comb$MTW_var, comb$Other_var)
result[[logger]] <- comb
}
for(logger in other_loggers){
comb <- expand.grid(
MNW_var = vars,
Other_var = vars
)
comb$Other_Logger <- logger
comb$correlation <- mapply(function(v1, v2){
cor(
df_wide[[paste0(v1,"_",target)]],
df_wide[[paste0(v2,"_",logger)]],
use = "complete.obs"
)
}, comb$MNW_var, comb$Other_var)
result[[logger]] <- comb
}
# Standort MT filtern
df_mt <- all_loggers %>%
filter(Standort == "MN")
# Wide-Format erzeugen
df_wide <- df_mt %>%
pivot_wider(
id_cols = DateTime,
names_from = Logger_ID,
values_from = c(
Temp_sonne_C,
Temp_schatten_C,
relLF_percent,
Taupunkt_C,
Licht_lux
)
)
vars <- c(
"Temp_sonne_C",
"Temp_schatten_C",
"relLF_percent",
"Taupunkt_C",
"Licht_lux"
)
target <- "MNW"
other_loggers <- unique(df_mt$Logger_ID)
other_loggers <- other_loggers[other_loggers != target]
result <- list()
for(logger in other_loggers){
comb <- expand.grid(
MNW_var = vars,
Other_var = vars
)
comb$Other_Logger <- logger
comb$correlation <- mapply(function(v1, v2){
cor(
df_wide[[paste0(v1,"_",target)]],
df_wide[[paste0(v2,"_",logger)]],
use = "complete.obs"
)
}, comb$MNW_var, comb$Other_var)
result[[logger]] <- comb
}
cross_logger_cor <- bind_rows(result)
cross_logger_cor
write_xlsx(cross_logger_cor, "Korrelationstabelle_MNW.xlsx")
# Standort MT filtern
df_mt <- all_loggers %>%
filter(Standort == "MT")
# Wide-Format erzeugen
df_wide <- df_mt %>%
pivot_wider(
id_cols = DateTime,
names_from = Logger_ID,
values_from = c(
Temp_sonne_C,
Temp_schatten_C,
relLF_percent,
Taupunkt_C,
Licht_lux
)
)
# Ziel-Logger festlegen
target <- "MTM"
# Alle anderen Logger automatisch bestimmen
logger_ids <- unique(df_mt$Logger_ID)
logger_ids <- logger_ids[logger_ids != target]
# Korrelation berechnen
cor_results <- lapply(logger_ids, function(id){
data.frame(
Logger = id,
cor_temp_out = cor(
df_wide[[paste0("Temp_sonne_C_", target)]],
df_wide[[paste0("Temp_sonne_C_", id)]],
use = "complete.obs"
),
cor_temp_in = cor(
df_wide[[paste0("Temp_schatten_C_", target)]],
df_wide[[paste0("Temp_schatten_C_", id)]],
use = "complete.obs"
),
cor_rh = cor(
df_wide[[paste0("relLF_percent_", target)]],
df_wide[[paste0("relLF_percent_", id)]],
use = "complete.obs"
),
cor_tau = cor(
df_wide[[paste0("Taupunkt_C_", target)]],
df_wide[[paste0("Taupunkt_C_", id)]],
use = "complete.obs"
),
cor_lux = cor(
df_wide[[paste0("Licht_lux_", target)]],
df_wide[[paste0("Licht_lux_", id)]],
use = "complete.obs"
)
)
}) %>%
bind_rows()
cor_results
vars <- c(
"Temp_sonne_C",
"Temp_schatten_C",
"relLF_percent",
"Taupunkt_C",
"Licht_lux"
)
target <- "MTM"
other_loggers <- unique(df_mt$Logger_ID)
other_loggers <- other_loggers[other_loggers != target]
result <- list()
for(logger in other_loggers){
comb <- expand.grid(
MTM_var = vars,
Other_var = vars
)
comb$Other_Logger <- logger
comb$correlation <- mapply(function(v1, v2){
cor(
df_wide[[paste0(v1,"_",target)]],
df_wide[[paste0(v2,"_",logger)]],
use = "complete.obs"
)
}, comb$MTM_var, comb$Other_var)
result[[logger]] <- comb
}
cross_logger_cor <- bind_rows(result)
cross_logger_cor
# erzeugte Daten wieder in die Originaltabelle einfügen
mtm_filled_long <- wide %>%
select(DateTime, MTM_filled_rf) %>%
rename(Temp_sonne_C_filled = MTM_filled_rf) %>%
mutate(Logger_ID = "MTM")
all_loggers_filled <- all_loggers_complete %>%
left_join(mtm_filled_long,
by = c("DateTime", "Logger_ID")) %>%
mutate(
Temp_sonne_C = ifelse(
Logger_ID == "MTM" & is.na(Temp_sonne_C),
Temp_sonne_C_filled,
Temp_sonne_C
)
) %>%
select(-Temp_sonne_C_filled)
View(all_loggers_filled)
